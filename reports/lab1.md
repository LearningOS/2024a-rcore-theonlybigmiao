
# ch3报告

## 1.实现功能

实现了一个获取当前任务信息的方法sys_task_inf，可以查询任务状态、系统调用及次数、调用时刻距任务第一次被调度时刻的时长。在TCB中增加记录任务次数的变量，并在TaskManager中增加返回当前任务调用次数和当前次数自增的方法，最后在系统调用处应用自增方法即可，难点是弄懂各文件任务调度的联系及练习中所要求的时间究竟是啥。此外就是对内核基本指令、状态切换和任务调度原理有了初步的认识。

## 2.简答作业

### (1)

运行测例，出现如下报错：

```

[kernel] PageFault in application, bad addr = 0x0, bad instruction = 0x804003c4, kernel killed it.

[kernel] IllegalInstruction in application, kernel killed it.

[kernel] IllegalInstruction in application, kernel killed it.

```

所用rustsbi版本为0.2.0。

### (2)
1.刚进入__restore时，a0代表系统调用的第一个参数。__restore可以在系统调用和异常处理时返回上下文信息，也能恢复任务切换时的上下文信息。

2.``ld t0,32*8(sp)``：特殊处理原sstatus寄存器，读取其值到t0;

``ld t1,33*8(sp)``：特殊处理原sepc寄存器的值，读取其值到t1;

``ld t2,2*8(sp)``：特殊处理原sscratch寄存器的值，读取其值到t2;

``csrw sstatus,t0``：将t0中的值读到sstatus;

``csrw sepc,t1``：将t1中的值读到sepc;

``csrw sscratch,t2``：将t2中的值读到sscratch;

3.x2对应的用户栈指针已保存在sscratch寄存器，无需恢复；x4没有被使用，也无需恢复。

4.该指令后，sp 指向了用户栈的顶部，而 sscratch 中的值被 sp 的原始值覆盖，指向内核栈的顶部。如果需要返回内核态，这个值将被用来恢复内核栈指针。

5.在sret后发生切换，然后PC变为sepc的值。sepc存着中断前的指令地址，所以可以返回用户态。

6.sp和sscratch的值被交换。

7.ecall指令。

### 3.荣誉准则
1.在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

《你交流的对象说明》

2.此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

《你参考的资料说明》

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
